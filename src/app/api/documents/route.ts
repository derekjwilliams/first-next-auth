// app/api/documents/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import {
  createSupabaseServerClient, // Use the correctly defined server client creator
  getCurrentUserAttributes,
} from '@/lib/supabase-api/server' // Ensure path is correct
import { can } from '@/lib/permissions' // Import can for authorization checks
import { z } from 'zod'

// Zod schema for creating a document (keep this)
const createSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  content: z.string().optional(),
  // Ensure enum values match your DB ENUM type 'sensitivity'
  sensitivity: z.enum(['public', 'internal', 'confidential']).default('internal'),
  department: z.string().nullable().optional(), // Allow null explicitly if desired
})

// --- GET /api/documents --- (List Documents from Supabase)
export async function GET(request: NextRequest) {
  const cookieStore = await cookies()
  // Create a Supabase client for this request context
  const supabase = createSupabaseServerClient(cookieStore)

  try {
    // 1. Auth: Get user (optional, RLS handles anon access if configured)
    // We don't strictly *need* the user attributes here for the query itself,
    // as RLS uses auth.uid() directly. But it could be useful for logging.
    // const user = await getCurrentUserAttributes();
    // console.log(`API GET /documents: Request by user ${user?.id ?? 'anon'}`);

    // 2. Fetch Data from Supabase
    // RLS automatically filters the results based on the authenticated user
    // and the SELECT policies you've defined on the 'documents' table.
    const { data: documents, error } = await supabase
      .from('documents')
      .select('*') // Select all columns
      .order('created_at', { ascending: false }) // Optional: order results

    // 3. Handle potential errors from Supabase query
    if (error) {
      console.error('API GET /documents: Supabase error:', error)
      // Don't expose detailed error messages to the client in production
      return NextResponse.json({ error: 'Failed to fetch documents' }, { status: 500 })
    }

    // 4. Return Data (filtered by RLS)
    return NextResponse.json(documents ?? []) // Return fetched documents or empty array
  } catch (err) {
    // Catch unexpected errors during the process
    console.error('API GET /documents: Unexpected error:', err)
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
  }
}

// --- POST /api/documents --- (Create Document in Supabase)
export async function POST(request: NextRequest) {
  const cookieStore = await cookies()
  // Create a Supabase client for this request context
  const supabase = createSupabaseServerClient(cookieStore)

  try {
    // 1. Authentication & User Attributes (Required for owner_id and authz check)
    const user = await getCurrentUserAttributes()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // 2. Authorization Check (ABAC for 'create' action)
    // This check uses your application logic before hitting the DB RLS policy.
    if (!can(user, 'create')) {
      console.warn(`API POST /documents: Permission Denied - User ${user.id} tried 'create'`)
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // 3. Input Validation
    let validatedData
    try {
      const body = await request.json()
      validatedData = createSchema.parse(body)
    } catch (error) {
      console.error('API POST /documents: Invalid request body:', error)
      // Provide detailed validation errors in development if helpful
      const details = error instanceof z.ZodError ? error.errors : (error as Error).message
      return NextResponse.json({ error: 'Bad Request', details }, { status: 400 })
    }

    // 4. Prepare Data for Supabase Insertion
    // Map validated data to database column names if they differ
    // Ensure required fields like owner_id are included
    const documentToInsert = {
      title: validatedData.title,
      content: validatedData.content,
      sensitivity: validatedData.sensitivity,
      // Set owner_id from the authenticated user
      owner_id: user.id,
      // Set department: use provided value or default to user's department if applicable
      department: validatedData.department !== undefined ? validatedData.department : user.department,
      // Timestamps (created_at, updated_at) have defaults in the DB schema
      // ID is generated by the DB (gen_random_uuid())
    }

    // 5. Perform Supabase Insertion
    const { data: newDocument, error: insertError } = await supabase
      .from('documents')
      .insert(documentToInsert)
      .select() // Select the newly inserted row
      .single() // Expect only one row to be inserted and returned

    // 6. Handle potential errors from Supabase insert
    if (insertError) {
      console.error('API POST /documents: Supabase insert error:', insertError)
      // Check for specific errors, e.g., RLS violation (though `can` check should prevent)
      if (insertError.code === '42501') {
        // RLS permission denied code
        return NextResponse.json({ error: 'Forbidden by database policy' }, { status: 403 })
      }
      return NextResponse.json({ error: 'Failed to create document' }, { status: 500 })
    }

    // 7. Return Success Response (Created) with the new document data
    return NextResponse.json(newDocument, { status: 201 }) // 201 Created status
  } catch (err) {
    // Catch unexpected errors
    console.error('API POST /documents: Unexpected error:', err)
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
  }
}
