// app/api/documents/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import {
  createSupabaseServerClient, // Use the correctly defined server client creator
  getCurrentUserAttributes,
} from '@/lib/supabase-api/server' // Ensure path is correct
import { can } from '@/lib/permissions' // Import can for authorization checks
import { z } from 'zod'
import { Database } from '@/utils/database.types'
import { SupabaseClient } from '@supabase/supabase-js'

// Zod schema for creating a document (keep this)
const createSchema = z.object({
  title: z.string().min(1, 'Title is required'),
  content: z.string().optional(),
  // Ensure enum values match your DB ENUM type 'sensitivity'
  sensitivity: z.enum(['public', 'internal', 'confidential']).default('internal'),
  department: z.string().nullable().optional(), // Allow null explicitly if desired
})

// --- GET /api/documents --- (List Documents from Supabase)
export async function GET(request: NextRequest) {
  const cookieStore = await cookies()
  // Create a Supabase client for this request context
  const supabase = createSupabaseServerClient(cookieStore)

  try {
    // 1. Auth: Get user (optional, RLS handles anon access if configured)
    // We don't strictly *need* the user attributes here for the query itself,
    // as RLS uses auth.uid() directly. But it could be useful for logging.
    // const user = await getCurrentUserAttributes();
    // console.log(`API GET /documents: Request by user ${user?.id ?? 'anon'}`);

    // 2. Fetch Data from Supabase
    // RLS automatically filters the results based on the authenticated user
    // and the SELECT policies you've defined on the 'documents' table.
    const { data: documents, error } = await supabase
      .from('documents')
      .select('*') // Select all columns
      .order('created_at', { ascending: false }) // Optional: order results

    // 3. Handle potential errors from Supabase query
    if (error) {
      console.error('API GET /documents: Supabase error:', error)
      // Don't expose detailed error messages to the client in production
      return NextResponse.json({ error: 'Failed to fetch documents' }, { status: 500 })
    }

    // 4. Return Data (filtered by RLS)
    return NextResponse.json(documents ?? []) // Return fetched documents or empty array
  } catch (err) {
    // Catch unexpected errors during the process
    console.error('API GET /documents: Unexpected error:', err)
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
  }
}

// --- POST /api/documents --- (Create Document in Supabase)
/*
export async function POST(request: NextRequest) {
  const cookieStore = await cookies()
  // Create a Supabase client for this request context
  const supabase = createSupabaseServerClient(cookieStore)

  try {
    // 1. Authentication & User Attributes (Required for owner_id and authz check)
    const user = await getCurrentUserAttributes()
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // 2. Authorization Check (ABAC for 'create' action)
    // This check uses your application logic before hitting the DB RLS policy.
    if (!can(user, 'create')) {
      console.warn(`API POST /documents: Permission Denied - User ${user.id} tried 'create'`)
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // 3. Input Validation
    let validatedData
    try {
      const body = await request.json()
      validatedData = createSchema.parse(body)
    } catch (error) {
      console.error('API POST /documents: Invalid request body:', error)
      // Provide detailed validation errors in development if helpful
      const details = error instanceof z.ZodError ? error.errors : (error as Error).message
      return NextResponse.json({ error: 'Bad Request', details }, { status: 400 })
    }

    // 4. Prepare Data for Supabase Insertion
    // Map validated data to database column names if they differ
    // Ensure required fields like owner_id are included
    const documentToInsert = {
      title: validatedData.title,
      content: validatedData.content,
      sensitivity: validatedData.sensitivity,
      // Set owner_id from the authenticated user
      owner_id: user.id,
      // Set department: use provided value or default to user's department if applicable
      department: validatedData.department !== undefined ? validatedData.department : user.department,
      // Timestamps (created_at, updated_at) have defaults in the DB schema
      // ID is generated by the DB (gen_random_uuid())
    }

    // 5. Perform Supabase Insertion

    type DocumentsInsert = Database['public']['Tables']['documents']['Insert']

    const { data: newDocument, error: insertError } = await supabase
      .from('documents')
      .insert(documentToInsert)
      .select() // Select the newly inserted row
      .single() // Expect only one row to be inserted and returned

    // 6. Handle potential errors from Supabase insert
    if (insertError) {
      console.error('API POST /documents: Supabase insert error:', insertError)
      // Check for specific errors, e.g., RLS violation (though `can` check should prevent)
      if (insertError.code === '42501') {
        // RLS permission denied code
        return NextResponse.json({ error: 'Forbidden by database policy' }, { status: 403 })
      }
      return NextResponse.json({ error: 'Failed to create document' }, { status: 500 })
    }

    // 7. Return Success Response (Created) with the new document data
    return NextResponse.json(newDocument, { status: 201 }) // 201 Created status
  } catch (err) {
    // Catch unexpected errors
    console.error('API POST /documents: Unexpected error:', err)
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
  }
}
  */

// // app/api/documents/route.ts
// import { NextRequest, NextResponse } from 'next/server'
// import { cookies } from 'next/headers'
// import { createSupabaseServerClient, getCurrentUserAttributes } from '@/lib/supabase-api/server'
// import { can, ResourceAttributes, UserAttributes } from '@/lib/permissions' // Import can
// import { z } from 'zod'
// import { v4 as uuidv4 } from 'uuid' // For generating IDs

// // --- Simulation Data & Functions (Shared or separate instance) ---
// // Assuming documentsDb is accessible here or use a proper DB connection
// interface Document extends ResourceAttributes {
//   id: string
//   title: string
//   content?: string
// }

// // Reference the simulated DB from the other file (or use a real DB)
// import { documentsDb } from './testdata' // Adjust path if needed

// // Simulate fetching all documents (RLS would filter this in reality)
// async function getAllDocuments(user: UserAttributes | null): Promise<Document[]> {
//   console.log(`API: Fetching all documents for user ${user?.id ?? 'anon'}`)
//   // In real app: const { data } = await supabase.from('documents').select('*'); return data;
//   // RLS applied by Supabase automatically based on the authenticated user.
//   // Here, we simulate the filtering based on our `can` logic for demonstration.
//   return documentsDb.filter((doc) => can(user, 'read', doc))
// }

// // Simulate creating a document
// async function createDocument(data: Omit<Document, 'id'>): Promise<Document> {
//   console.log(`API: Creating document with title "${data.title}"`)
//   const newDoc: Document = {
//     ...data,
//     id: uuidv4(), // Generate a new ID
//   }
//   documentsDb.push(newDoc)
//   return { ...newDoc } // Return a copy
// }
// // --- End Simulation ---

// // Zod schema for creating a document
// const createSchema = z.object({
//   title: z.string().min(1, 'Title is required'),
//   content: z.string().optional(),
//   sensitivity: z.enum(['public', 'internal', 'confidential']).default('internal'),
//   department: z.string().optional(), // Could be auto-set based on user
// })

// // --- GET /api/documents --- (List Documents)
// export async function GET(request: NextRequest) {
//   const cookieStore = await cookies() // Use await

//   try {
//     // 1. Auth: Get user (can be null for public reads)
//     const user = await getCurrentUserAttributes()

//     // 2. Authorization (Optional Check for Listing Action itself):
//     // You *could* add a check like `if (!can(user, 'listDocuments')) return forbidden;`
//     // if the ability to even *request* the list is restricted.
//     // For now, we assume anyone can request, and RLS/filtering handles visibility.

//     // 3. Fetch Data (Simulated + Filtered)
//     // In a real app with RLS, you'd just do:
//     // const supabase = createSupabaseServerClient(cookieStore);
//     // const { data: documents, error } = await supabase.from('documents').select('*');
//     // if (error) throw error;
//     // RLS handles the filtering at the DB level.
//     // Our simulation mimics the *result* of RLS filtering:
//     const documents = await getAllDocuments(user)

//     // 4. Return Data
//     return NextResponse.json(documents)
//   } catch (error) {
//     console.error('API GET /documents: Error', error)
//     return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
//   }
// }

// // --- POST /api/documents --- (Create Document)
// export async function POST(request: NextRequest) {
//   const cookieStore = await cookies() // Use await

//   try {
//     // 1. Authentication & User Attributes
//     const user = await getCurrentUserAttributes()
//     if (!user) {
//       return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
//     }

//     // 2. Authorization Check (ABAC for 'create' action)
//     // The 'create' action might not have a specific resource yet.
//     if (!can(user, 'create')) {
//       console.warn(`API: Permission Denied - User ${user.id} tried 'create' document`)
//       return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
//     }

//     // 3. Input Validation
//     let validatedData
//     try {
//       const body = await request.json()
//       validatedData = createSchema.parse(body)
//     } catch (error) {
//       console.error('API POST: Invalid request body:', error)
//       return NextResponse.json({ error: 'Bad Request', details: (error as Error).message }, { status: 400 })
//     }

//     // 4. Prepare Data for Creation (e.g., set ownerId)
//     const documentData: Omit<Document, 'id'> = {
//       ...validatedData,
//       ownerId: user.id, // Set owner to the current user
//       // Auto-set department based on user if not provided and applicable
//       department: validatedData.department ?? user.department ?? undefined,
//     }

//     // 5. Perform Creation (Simulated)
//     // const supabase = createSupabaseServerClient(cookieStore); // Create client if needed
//     const newDocument = await createDocument(documentData)
//     // In real app: check for errors from createDocument/supabase call

//     // 6. Return Success Response (Created)
//     return NextResponse.json(newDocument, { status: 201 }) // 201 Created status
//   } catch (error) {
//     console.error('API POST /documents: Error', error)
//     return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
//   }
// }
